Q1
a.
Chaque sommet représente une opération vertex-split sur un des sommets du maillage.

b.
(A REVOIR)
Si on considère un noeud Vs qui est divisé en deux sommets Vs1 et Vs2, alors dans le DAG il y aura une dépendance évidente (OpVs -> OpVs1, OpVs2) entre le sommet représentant le vertex_split du noeud Vs et les sommets représentant les vertex_split pour les noeuds Vs1 et Vs2.
De plus un noeud V1 doit être traité avant un noeud V2 uniquement si l'opération vertex-split de V1 crée une arrête connectée à V2.

Q2
a.
On peut inclure le coût des communications en les modélisants par le poids affecté à chaque arrête.

b.
Pour la répartition de la charge dans les différentes parties, il faut que la somme des coûts de calcul d'une partie soit équivalente d'une partie à l'autre.
Bien sûr il faut faire attention aux dépendances qui peuvent nuire au temps de calcul (attente d'un résultat).
Les coûts de communications se présentent au niveau des dépendances entre les parties. 
Un bon mapping va limiter les coûts de communications en rassemblant les tâches interdépendantes dans une même partie attribuée à une même ressource néanmmoins envoyer plusieurs fois des petits résultats peut coûter moins qu'envoyer une fois un résultat de grande taille.
Il faut donc que chaque partie corresponde à un sous-graphe du graphe de dépendances pour limiter le volume des communicationse et que chaque partie contienne un nombre de noeud équivalent pour équilibrer la charge.

c.
(BONUS)
( reprendre tp2 OpenMP)

Q3
a.
Si un processeur commet une faute lors de l'exécution d'une tâche v il faut réexécuter toutes les tâches précédent la tâche v dans le graphe de dépendances.

b.
Si l'on sauvegarde les résultats de chaque tâche après exécution, il suffit de réexécuter la tâche ayant fauté. On obtient donc une moyenne de 1.

c.
(A REVOIR)

d.
(BONUS)

Q4
Chaque tâche s'éxecute l'une après l'autre, le temps total d'éxecution est donc égal à la somme des temps d'éxecution de chaque tâche. 
Pour la même raison que précédemment, il suffit juste de respecter l'ordre défini par les dépendances entre les tâches, ce qui correspond aussi, d'après la question 1, aux dépendances du DAG.

Q5
a.
A tout moment de l’algorithme, chaque nœud du graphe est dans un des trois possibles états :
— non numéroté et avec certains de ses prédécesseurs non numérotés correspond à X
— non numéroté et avec tous ses prédécesseurs numérotés correspond à Y
— numéroté correspond à Z
En effet, une fois que l'on a numéroté un sommet on l'ajoute à la liste Z.
Si un sommet a tous ses prédécesseurs dans Z (donc numérotés) on l'ajoute dans Y.
Le troisième état correspond donc à la liste X.

On initialise l'algorithme avec la liste Y qui contient les sommets n'ayant pas de dépendances.
Puis l'algorithme ajoute un sommet v dans cette liste uniquement lorsque tous les sommets dont il est directement dépendant (ses prédécesseurs) sont déjà numérotés. 
La numérotation, qui est faite à partir de la liste Y, respecte donc l'ordre topologique ou ordre partiel défini par les dépendances du graphe.

La numérotation se fait avec des nombres entiers, chaque sommet ayant un numéro unique et les entiers possédant un ordre total, l'ordre donné aux sommets est donc total.

b.
Toutes les actions, retirer, ajouter, numéroter sont en O(1) donc nous n'en tiendrons pas compte.
Le code de la ligne 8 à la ligne 10 (bloc si) utilise la fonction prec qui a un coût de c.
Ce bloc est inclus dans un bloucle qui parcours tous les sommets successeurs à un autre sommet c'est à dire qu'on parcours p arrêtes.
La boucle est donc en O(m*c). Pour pouvoir parcourir ces arrêtes, il faut comme dit ci-dessus, calculer les successeurs, ce qui ajoute un coût de c.
Donc l'intérieur de la boucle "tant que" est de complexité en O( c + m*c).
Tous les sommets du graphe seront ajoutés à la liste Y, que l'on parcours entièrement (ligne 3), donc on obtient une complexité de l'algorithme en O( n*(c + m*c)) = O( n*c*(m+1) ).
!!!!!!!! A REVOIR

Q6
Le parcour induit par l'utilisation d'une pile est un parcours du graphe en hauteur que l'on peut assimiler au parcours postfixe sur un arbre.
Le parcours induit par l'uitilisation d'une file est un parcours du graphe en largeur.

Q7
algo -> Félix -> FINI

Q8
a.
Le temps total d'exécution admet comme borne inférieure le nombre de noeud divisé par le nombre de ressource , n/r.
Dans le cas où la borne est atteinte, chaque ressource est utilisée à chaque étape du calcul.

b.
Les ressources limitent le nombre de tâches effectuées à chaque étape, la taille des listes est donc bornée par le nombre de ressource.

Q9
(ALGO) Greg -> FINI

Q10
On remarque que lorsque le graphe de dépendances est équilibré comme le DAG dag3, le nombre de ressources influe peu sur l'efficacité de l'algorithme.
On se rapproche en effet toujours de la borne inf n/r étapes de calcul car il y a toujours un nombre équivalent de tâches à exécuter quelque soit l'ordre d'exécution des tâches.

Pour les DAG de la forme de dag2, si r>1 comme il n'y a qu'une tâche source et que les degrès sortant sont inférieurs ou égale à 3, le nombres de tâches exécutables à chaque étape est 1 ou 2.
L'efficacité est donc mauvaise mais on ne peut faire mieux au vu du graphe.
L'algorithme à donc peu d'effet sur les graphes de cette forme.

Pour les DAG de forme plus quelconque comme dag1, le graphe étant assez équilibré on obtient des performances plus ou moins proche de la borne inf en fonction des dépendances et du nombre de ressources.

Pour des DAG de la forme de dag4, l'algorithme n'est pas efficace car il exécute toute les tâches du deuxième niveau de dépendances avant de passer au troisième alors même qu'il y a des taĉhes exécutables ce qui va donc donner un grand nombre d'étapes.
Celui-ci pourrait être réduit en organisant les taĉhes différemment (cf question 11). 

Q11
Comme vu à la question précédente, notre algorithme est inefficace lorsqu'il y a un sous-graphe présentant un grand nombre d'enchainement de dépendances.
Pour cela, il faut exécuter en priorité les tâches ayant le plus grand nombre de dépendances jusqu'à un de leur puit.
Plutôt que d'utiliser une file pour la liste Y dans notre tri, nous utiliserons simplement une liste triée en fonction de ce nombre, l'ordre topologique partiel étant respecté par la structure de l'algorithme de la question 7. (A REPRENDRE)


Q12
(ALGO) -> FELIX

Q13

Q14
Il suffit qu'une tâche ne demande pas plus de mémoire mi que de mémoire totale M.
On a donc (C) : pour tout i, mi <= M

Q15
(ALGO) -> GREG + (QUESTIONS)


Q16
a.
b.
c. (BONUS)

Q17
(BONUS)
